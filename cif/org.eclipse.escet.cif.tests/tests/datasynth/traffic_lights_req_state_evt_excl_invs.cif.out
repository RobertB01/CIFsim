Reading CIF file "datasynth/traffic_lights_req_state_evt_excl_invs.cif".
Preprocessing CIF specification.
Converting CIF specification to internal format.

CIF variables and location pointers:
  Nr     Kind              Type  Name    Group  BDD vars  CIF values  BDD values  Values used
  -----  ----------------  ----  ------  -----  --------  ----------  ----------  -----------
  1      location pointer  n/a   LightA  0      1 * 2     2 * 2       2 * 2       100%
  2      location pointer  n/a   LightB  1      1 * 2     2 * 2       2 * 2       100%
  -----  ----------------  ----  ------  -----  --------  ----------  ----------  -----------
  Total                                  2      4         8           8           100%

Applying variable ordering:
  Applying model variable order.

  Skipping variable ordering algorithm(s): no graph edges.

Variable order unchanged.

Starting data-based synthesis.

Invariant (components state plant inv):      true
Invariant (locations state plant invariant): true
Invariant (system state plant invariant):    true

Invariant (components state req invariant):  true
Invariant (locations state req invariant):   true
Invariant (system state req invariant):      true

Initial   (discrete variables):              true
Initial   (components init predicate):       true
Initial   (aut/locs init predicate):         LightA.Red
Initial   (aut/locs init predicate):         LightB.Red
Initial   (auts/locs init predicate):        LightA.Red and LightB.Red
Initial   (uncontrolled system):             LightA.Red and LightB.Red
Initial   (system, combined init/plant inv): LightA.Red and LightB.Red
Initial   (system, combined init/state inv): LightA.Red and LightB.Red

Marked    (components marker predicate):     true
Marked    (aut/locs marker predicate):       LightA.Red
Marked    (aut/locs marker predicate):       LightB.Red
Marked    (auts/locs marker predicate):      LightA.Red and LightB.Red
Marked    (uncontrolled system):             LightA.Red and LightB.Red
Marked    (system, combined mark/plant inv): LightA.Red and LightB.Red
Marked    (system, combined mark/state inv): LightA.Red and LightB.Red

State/event exclusion plants:
  None

State/event exclusion requirements:
  Event "green_A" needs:
    LightB.Red
  Event "green_B" needs:
    LightA.Red

Uncontrolled system:
  State: (controlled-behavior: ?)
    Edge: (event: green_A) (guard: LightA.Red) (assignments: LightA := LightA.Green)
    Edge: (event: red_A) (guard: LightA.Green) (assignments: LightA := LightA.Red)
    Edge: (event: green_B) (guard: LightB.Red) (assignments: LightB := LightB.Green)
    Edge: (event: red_B) (guard: LightB.Green) (assignments: LightB := LightB.Red)

Restricting behavior using state/event exclusion plants.

Initialized controlled-behavior predicate: true.
Initialized controlled-initialization predicate: LightA.Red and LightB.Red.

Restricting behavior using state requirements.

Extending controlled-behavior predicate using variable ranges.

Restricting behavior using state/event exclusion requirements.

Edge (event: green_A) (guard: LightA.Red) (assignments: LightA := LightA.Green): guard: LightA.Red -> LightA.Red and LightB.Red [state/event exclusion requirement: LightB.Red].
Edge (event: green_B) (guard: LightB.Red) (assignments: LightB := LightB.Green): guard: LightB.Red -> LightA.Red and LightB.Red [state/event exclusion requirement: LightA.Red].

Restricted behavior using state/event exclusion requirements:
  State: (controlled-behavior: true)
    Edge: (event: green_A) (guard: LightA.Red -> LightA.Red and LightB.Red) (assignments: LightA := LightA.Green)
    Edge: (event: red_A) (guard: LightA.Green) (assignments: LightA := LightA.Red)
    Edge: (event: green_B) (guard: LightB.Red -> LightA.Red and LightB.Red) (assignments: LightB := LightB.Green)
    Edge: (event: red_B) (guard: LightB.Green) (assignments: LightB := LightB.Red)

Round 1: started.

Round 1: computing backward controlled-behavior predicate.
Backward controlled-behavior: LightA.Red and LightB.Red [marker predicate]
Backward reachability: iteration 1.
Backward controlled-behavior: LightA.Red and LightB.Red -> LightB.Red [backward reach with edge: (event: red_A) (guard: LightA.Green) (assignments: LightA := LightA.Red), restricted to current/previous controlled-behavior predicate: true]
Backward controlled-behavior: LightB.Red -> true [backward reach with edge: (event: red_B) (guard: LightB.Green) (assignments: LightB := LightB.Red), restricted to current/previous controlled-behavior predicate: true]
Backward reachability: iteration 2.
Backward controlled-behavior: true [fixed point].

Round 1: computing backward uncontrolled bad-state predicate.
Backward uncontrolled bad-state: false [current/previous controlled behavior predicate]
Backward reachability: iteration 1.

Round 1: computing forward controlled-behavior predicate.
Forward controlled-behavior: LightA.Red and LightB.Red [initialization predicate]
Forward reachability: iteration 1.
Forward controlled-behavior: LightA.Red and LightB.Red -> LightB.Red [forward reach with edge: (event: green_A) (guard: LightA.Red -> LightA.Red and LightB.Red) (assignments: LightA := LightA.Green), restricted to current/previous controlled-behavior predicate: true]
Forward controlled-behavior: LightB.Red -> LightA.Red or LightB.Red [forward reach with edge: (event: green_B) (guard: LightB.Red -> LightA.Red and LightB.Red) (assignments: LightB := LightB.Green), restricted to current/previous controlled-behavior predicate: true]
Forward reachability: iteration 2.
Forward controlled-behavior: LightA.Red or LightB.Red [fixed point].
Controlled behavior: true -> LightA.Red or LightB.Red.

Round 1: finished, need another round.

Round 2: started.

Round 2: computing backward controlled-behavior predicate.
Backward controlled-behavior: LightA.Red and LightB.Red [marker predicate]
Backward reachability: iteration 1.
Backward controlled-behavior: LightA.Red and LightB.Red -> LightB.Red [backward reach with edge: (event: red_A) (guard: LightA.Green) (assignments: LightA := LightA.Red), restricted to current/previous controlled-behavior predicate: LightA.Red or LightB.Red]
Backward controlled-behavior: LightB.Red -> LightA.Red or LightB.Red [backward reach with edge: (event: red_B) (guard: LightB.Green) (assignments: LightB := LightB.Red), restricted to current/previous controlled-behavior predicate: LightA.Red or LightB.Red]
Backward reachability: iteration 2.
Backward controlled-behavior: LightA.Red or LightB.Red [fixed point].

Round 2: computing backward uncontrolled bad-state predicate.
Backward uncontrolled bad-state: LightA.Green and LightB.Green [current/previous controlled behavior predicate]
Backward reachability: iteration 1.

Round 2: finished, controlled behavior is stable.

Computing controlled system guards.

Final synthesis result:
  State: (controlled-behavior: LightA.Red or LightB.Red)
    Edge: (event: green_A) (guard: LightA.Red -> LightA.Red and LightB.Red) (assignments: LightA := LightA.Green)
    Edge: (event: red_A) (guard: LightA.Green) (assignments: LightA := LightA.Red)
    Edge: (event: green_B) (guard: LightB.Red -> LightA.Red and LightB.Red) (assignments: LightB := LightB.Green)
    Edge: (event: red_B) (guard: LightB.Green) (assignments: LightB := LightB.Red)

Controlled system:                     exactly 3 states.

Initial (synthesis result):            LightA.Red or LightB.Red
Initial (uncontrolled system):         LightA.Red and LightB.Red
Initial (controlled system):           LightA.Red and LightB.Red
Initial (removed by supervisor):       false
Initial (added by supervisor):         true

Simplification of controlled system under the assumption of the plants:
  Event green_A: guard: LightA.Red and LightB.Red -> LightB.Red [assume LightA.Red].
  Event red_A: guard: LightA.Green -> true [assume LightA.Green].
  Event green_B: guard: LightA.Red and LightB.Red -> LightA.Red [assume LightB.Red].
  Event red_B: guard: LightB.Green -> true [assume LightB.Green].

Constructing output CIF specification.
Writing output CIF file "datasynth/traffic_lights_req_state_evt_excl_invs.ctrlsys.real.cif".
