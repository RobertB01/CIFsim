Reading CIF file "datasynth/channel.cif".
Preprocessing CIF specification.
Converting CIF specification to internal format.

CIF variables and location pointers:
  Nr     Kind               Type       Name    Group  BDD vars  CIF values  BDD values  Values used
  -----  -----------------  ---------  ------  -----  --------  ----------  ----------  -----------
  1      discrete variable  int[0..3]  cnt.c   0      2 * 2     4 * 2       4 * 2       100%
  2      discrete variable  int[0..3]  rcv1.x  1      2 * 2     4 * 2       4 * 2       100%
  3      discrete variable  int[0..3]  rcv2.x  2      2 * 2     4 * 2       4 * 2       100%
  -----  -----------------  ---------  ------  -----  --------  ----------  ----------  -----------
  Total                                        3      12        24          24          100%

Applying automatic variable ordering:
  Number of hyper-edges: 11
  Number of graph edges: 3

  Applying 2 algorithms, sequentially:
    Applying FORCE algorithm.
    Maximum number of iterations: 20
    Total span:   3 (total)   0.27 (avg/edge) / WES:   0.262626 (total)   0.023875 (avg/edge) [before]
    Total span:   3 (total)   0.27 (avg/edge) / WES:   0.262626 (total)   0.023875 (avg/edge) [iteration 1]
    Total span:   3 (total)   0.27 (avg/edge) / WES:   0.262626 (total)   0.023875 (avg/edge) [after]

    Applying sliding window algorithm.
    Window length: 3
    Total span:   3 (total)   0.27 (avg/edge) / WES:   0.262626 (total)   0.023875 (avg/edge) [before]
    Total span:   3 (total)   0.27 (avg/edge) / WES:   0.262626 (total)   0.023875 (avg/edge) [after]

Variable order unchanged.

Starting data-based synthesis.

Invariant (components state plant inv):      true
Invariant (locations state plant invariant): true
Invariant (system state plant invariant):    true

Invariant (components state req invariant):  true
Invariant (locations state req invariant):   true
Invariant (system state req invariant):      true

Initial   (discrete variable 0):             cnt.c = 0
Initial   (discrete variable 1):             rcv1.x = 0
Initial   (discrete variable 2):             rcv2.x = 0
Initial   (discrete variables):              cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)
Initial   (components init predicate):       true
Initial   (aut/locs init predicate):         true
Initial   (aut/locs init predicate):         true
Initial   (aut/locs init predicate):         true
Initial   (aut/locs init predicate):         true
Initial   (aut/locs init predicate):         true
Initial   (auts/locs init predicate):        true
Initial   (uncontrolled system):             cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)
Initial   (system, combined init/plant inv): cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)
Initial   (system, combined init/state inv): cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)

Marked    (components marker predicate):     true
Marked    (aut/locs marker predicate):       true
Marked    (aut/locs marker predicate):       true
Marked    (aut/locs marker predicate):       true
Marked    (aut/locs marker predicate):       true
Marked    (aut/locs marker predicate):       true
Marked    (auts/locs marker predicate):      true
Marked    (uncontrolled system):             true
Marked    (system, combined mark/plant inv): true
Marked    (system, combined mark/state inv): true

State/event exclusion plants:
  None

State/event exclusion requirements:
  Event "e" needs:
    rcv1.x = 0 or (rcv1.x = 2 and rcv2.x = 1 or (rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)

Uncontrolled system:
  State: (controlled-behavior: ?)
    Edge: (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1)
    Edge: (event: e) (guard: cnt.c = 1) (assignments: rcv1.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv2.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv1.x := 2)
    Edge: (event: e) (guard: cnt.c = 2) (assignments: rcv2.x := 2)

Restricting behavior using state/event exclusion plants.

Initialized controlled-behavior predicate: true.

Restricting behavior using state requirements.

Extending controlled-behavior predicate using variable ranges.

Restricting behavior using state/event exclusion requirements.

Edge (event: e) (guard: cnt.c = 1) (assignments: rcv1.x := 1): guard: cnt.c = 1 -> cnt.c = 1 and rcv1.x = 0 or (cnt.c = 1 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 1 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)) [requirement: rcv1.x = 0 or (rcv1.x = 2 and rcv2.x = 1 or (rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)].
Edge (event: e) (guard: cnt.c = 2) (assignments: rcv2.x := 2): guard: cnt.c = 2 -> cnt.c = 2 and rcv1.x = 0 or (cnt.c = 2 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 2 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)) [requirement: rcv1.x = 0 or (rcv1.x = 2 and rcv2.x = 1 or (rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)].

Restricted behavior using state/event exclusion requirements:
  State: (controlled-behavior: true)
    Edge: (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1)
    Edge: (event: e) (guard: cnt.c = 1 -> cnt.c = 1 and rcv1.x = 0 or (cnt.c = 1 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 1 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv1.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv2.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv1.x := 2)
    Edge: (event: e) (guard: cnt.c = 2 -> cnt.c = 2 and rcv1.x = 0 or (cnt.c = 2 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 2 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv2.x := 2)

Round 1: started.

Round 1: computing backward controlled-behavior predicate.
Backward controlled-behavior: true [marker predicate]
Backward reachability: iteration 1.

Round 1: computing backward uncontrolled bad-state predicate.
Backward uncontrolled bad-state: false [current/previous controlled behavior predicate]
Backward reachability: iteration 1.

Round 1: computing forward controlled-behavior predicate.
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) [initialization predicate]
Forward reachability: iteration 1.
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) -> (cnt.c = 0 or cnt.c = 1) and (rcv1.x = 0 and rcv2.x = 0) [forward reach with edge: (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1), restricted to current/previous controlled-behavior predicate: true]
Forward controlled-behavior: (cnt.c = 0 or cnt.c = 1) and (rcv1.x = 0 and rcv2.x = 0) -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) [forward reach with edge: (event: e) (guard: cnt.c = 1 -> cnt.c = 1 and rcv1.x = 0 or (cnt.c = 1 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 1 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv1.x := 1), restricted to current/previous controlled-behavior predicate: true]
Forward reachability: iteration 2.
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0)) [forward reach with edge: (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1), restricted to current/previous controlled-behavior predicate: true]
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0)) -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0)) [forward reach with edge: (event: e) (guard: cnt.c = 2 -> cnt.c = 2 and rcv1.x = 0 or (cnt.c = 2 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 2 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv2.x := 2), restricted to current/previous controlled-behavior predicate: true]
Forward reachability: iteration 3.
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0)) -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))) [forward reach with edge: (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1), restricted to current/previous controlled-behavior predicate: true]
Forward reachability: iteration 4.
Forward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))) [fixed point].
Controlled behavior: true -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))).

Round 1: finished, need another round.

Round 2: started.

Round 2: computing backward controlled-behavior predicate.
Backward controlled-behavior: true [marker predicate]
Backward controlled-behavior: true -> cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))) [restricted to current/previous controlled-behavior predicate: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0)))]
Backward reachability: iteration 1.
Backward controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))) [fixed point].

Round 2: computing backward uncontrolled bad-state predicate.
Backward uncontrolled bad-state: (cnt.c != 0 or (rcv1.x != 0 or rcv2.x != 0)) and ((cnt.c != 2 or rcv1.x != 0 or (rcv2.x = 1 or rcv2.x = 3)) and (cnt.c != 2 or (rcv1.x != 1 or rcv2.x != 0))) and ((cnt.c != 1 or rcv1.x = 2 or (rcv1.x = 3 or rcv2.x != 0)) and ((cnt.c != 3 or rcv1.x != 0 or (rcv2.x = 1 or rcv2.x = 3)) and (cnt.c != 3 or (rcv1.x != 1 or rcv2.x != 0)))) [current/previous controlled behavior predicate]
Backward reachability: iteration 1.

Round 2: finished, controlled behavior is stable.

Computing controlled system guards.

Edge (event: cnt.next) (guard: cnt.c != 3) (assignments: cnt.c := cnt.c + 1): guard: cnt.c != 3 -> cnt.c = 0 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or (cnt.c = 1 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 1 and (rcv1.x = 1 and rcv2.x = 0))).
Edge (event: e) (guard: cnt.c = 1 -> cnt.c = 1 and rcv1.x = 0 or (cnt.c = 1 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 1 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv1.x := 1): guard: cnt.c = 1 and rcv1.x = 0 or (cnt.c = 1 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 1 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)) -> cnt.c = 1 and (rcv1.x = 0 and rcv2.x = 0).
Edge (event: e) (guard: cnt.c = 2 -> cnt.c = 2 and rcv1.x = 0 or (cnt.c = 2 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 2 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1))) (assignments: rcv2.x := 2): guard: cnt.c = 2 and rcv1.x = 0 or (cnt.c = 2 and (rcv1.x = 2 and rcv2.x = 1) or cnt.c = 2 and ((rcv1.x = 1 or rcv1.x = 3) and rcv2.x = 1)) -> cnt.c = 2 and rcv1.x = 0.

Final synthesis result:
  State: (controlled-behavior: cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0))))
    Edge: (event: cnt.next) (guard: cnt.c != 3 -> cnt.c = 0 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or (cnt.c = 1 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 1 and (rcv1.x = 1 and rcv2.x = 0)))) (assignments: cnt.c := cnt.c + 1)
    Edge: (event: e) (guard: cnt.c = 1 -> cnt.c = 1 and (rcv1.x = 0 and rcv2.x = 0)) (assignments: rcv1.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv2.x := 1)
    Edge: (event: e) (guard: false) (assignments: rcv1.x := 2)
    Edge: (event: e) (guard: cnt.c = 2 -> cnt.c = 2 and rcv1.x = 0) (assignments: rcv2.x := 2)

Controlled system:                     exactly 9 states.

Initial (synthesis result):            cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0) or (cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0)) or (cnt.c = 1 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or (cnt.c = 3 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 3 and (rcv1.x = 1 and rcv2.x = 0)))
Initial (uncontrolled system):         cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)
Initial (controlled system):           cnt.c = 0 and (rcv1.x = 0 and rcv2.x = 0)
Initial (removed by supervisor):       false
Initial (added by supervisor):         true

Simplification of controlled system under the assumption of the plants:
  Event cnt.next: guard: cnt.c = 0 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or (cnt.c = 1 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or cnt.c = 1 and (rcv1.x = 1 and rcv2.x = 0))) -> cnt.c = 0 and ((rcv1.x = 0 or rcv1.x = 1) and rcv2.x = 0) or cnt.c = 2 and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 2 and (rcv1.x = 1 and rcv2.x = 0) or ((cnt.c = 1 or cnt.c = 3) and (rcv1.x = 0 and (rcv2.x = 0 or rcv2.x = 2)) or (cnt.c = 1 or cnt.c = 3) and (rcv1.x = 1 and rcv2.x = 0))) [assume cnt.c != 3].
  Event e: guard: cnt.c = 2 and rcv1.x = 0 or cnt.c = 1 and (rcv1.x = 0 and rcv2.x = 0) -> (cnt.c = 0 or cnt.c = 2) and rcv1.x = 0 or (cnt.c = 1 or cnt.c = 3) and (rcv1.x = 0 and rcv2.x = 0) [assume cnt.c != 0 and cnt.c != 3].

Constructing output CIF specification.
Writing output CIF file "datasynth/channel.ctrlsys.real.cif".
