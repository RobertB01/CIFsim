Loading CIF specification "controllercheck/bounded_response/bounded_button_lamp_timer_sup_hw.cif"...
Preparing for BDD-based checks...

CIF variables and location pointers:
  Nr     Kind               Type  Name          Group  BDD vars  CIF values  BDD values  Values used
  -----  -----------------  ----  ------------  -----  --------  ----------  ----------  -----------
  1      location pointer   n/a   Button        0      1 * 2     2 * 2       2 * 2       100%
  2      location pointer   n/a   Lamp          1      1 * 2     2 * 2       2 * 2       100%
  3      location pointer   n/a   Timer         2      1 * 2     2 * 2       2 * 2       100%
  4      location pointer   n/a   Cycle         3      3 * 2     5 * 2       8 * 2       ~63%
  5      location pointer   n/a   ButtonHW      4      1 * 2     2 * 2       2 * 2       100%
  6      input variable     bool  ButtonHW.bit  5      1 * 2     2 * 2       2 * 2       100%
  7      location pointer   n/a   LampHW        6      1 * 2     2 * 2       2 * 2       100%
  8      discrete variable  bool  LampHW.bit    7      1 * 2     2 * 2       2 * 2       100%
  -----  -----------------  ----  ------------  -----  --------  ----------  ----------  -----------
  Total                                         8      20        38          44          ~86%

Applying variable ordering:
  Applying 4 orderers, sequentially:
    Applying sorted variable order:
      Effect: both

    Applying DCSH algorithm:
      Metric: wes
      Relations: legacy
      Effect: var-order
      Number of hyper-edges: 8

      Applying Weighted Cuthill-McKee algorithm:
        Node finder: george-liu
        Relations: legacy
        Effect: var-order
        Number of graph edges: 13

        Total span:   19 (total)   2.38 (avg/edge) / WES:   0.578125 (total)   0.072266 (avg/edge) [before]
        Total span:   15 (total)   1.88 (avg/edge) / WES:   0.460938 (total)   0.057617 (avg/edge) [after]

      Found new best variable order.

      Applying Sloan algorithm:
        Relations: legacy
        Effect: var-order
        Number of graph edges: 13

        Total span:   19 (total)   2.38 (avg/edge) / WES:   0.578125 (total)   0.072266 (avg/edge) [before]
        Total span:   19 (total)   2.38 (avg/edge) / WES:   0.488281 (total)   0.061035 (avg/edge) [after]

      Applying 2 orderers, sequentially:
        Applying Weighted Cuthill-McKee algorithm:
          Node finder: george-liu
          Relations: legacy
          Effect: var-order
          Number of graph edges: 13

          Total span:   19 (total)   2.38 (avg/edge) / WES:   0.578125 (total)   0.072266 (avg/edge) [before]
          Total span:   15 (total)   1.88 (avg/edge) / WES:   0.460938 (total)   0.057617 (avg/edge) [after]

        Reversing the variable order:
          Relations: legacy
          Effect: var-order
          Number of hyper-edges: 8

          Total span:   15 (total)   1.88 (avg/edge) / WES:   0.460938 (total)   0.057617 (avg/edge) [before]
          Total span:   15 (total)   1.88 (avg/edge) / WES:   0.460938 (total)   0.057617 (avg/edge) [reversed]

      Found new best variable order.

      Applying 2 orderers, sequentially:
        Applying Sloan algorithm:
          Relations: legacy
          Effect: var-order
          Number of graph edges: 13

          Total span:   19 (total)   2.38 (avg/edge) / WES:   0.578125 (total)   0.072266 (avg/edge) [before]
          Total span:   19 (total)   2.38 (avg/edge) / WES:   0.488281 (total)   0.061035 (avg/edge) [after]

        Reversing the variable order:
          Relations: legacy
          Effect: var-order
          Number of hyper-edges: 8

          Total span:   19 (total)   2.38 (avg/edge) / WES:   0.488281 (total)   0.061035 (avg/edge) [before]
          Total span:   19 (total)   2.38 (avg/edge) / WES:   0.488281 (total)   0.061035 (avg/edge) [reversed]

    Applying FORCE algorithm:
      Metric: total-span
      Relations: linearized
      Effect: var-order
      Number of hyper-edges: 10
      Maximum number of iterations: 30

      Total span:   27 (total)   2.70 (avg/edge) / WES:   0.678125 (total)   0.067813 (avg/edge) [before]
      Total span:   27 (total)   2.70 (avg/edge) / WES:   0.678125 (total)   0.067813 (avg/edge) [iteration 1]
      Total span:   27 (total)   2.70 (avg/edge) / WES:   0.678125 (total)   0.067813 (avg/edge) [after]

    Applying sliding window algorithm:
      Size: 4
      Metric: total-span
      Relations: linearized
      Effect: var-order
      Number of hyper-edges: 10
      Window length: 4

      Total span:   27 (total)   2.70 (avg/edge) / WES:   0.678125 (total)   0.067813 (avg/edge) [before]
      Total span:   27 (total)   2.70 (avg/edge) / WES:   0.678125 (total)   0.067813 (avg/edge) [after]

Variable order changed.

CIF variables and location pointers:
  Nr     Kind               Type  Name          Group  BDD vars  CIF values  BDD values  Values used
  -----  -----------------  ----  ------------  -----  --------  ----------  ----------  -----------
  1      discrete variable  bool  LampHW.bit    0      1 * 2     2 * 2       2 * 2       100%
  2      location pointer   n/a   LampHW        1      1 * 2     2 * 2       2 * 2       100%
  3      location pointer   n/a   Lamp          2      1 * 2     2 * 2       2 * 2       100%
  4      location pointer   n/a   Timer         3      1 * 2     2 * 2       2 * 2       100%
  5      location pointer   n/a   Cycle         4      3 * 2     5 * 2       8 * 2       ~63%
  6      input variable     bool  ButtonHW.bit  5      1 * 2     2 * 2       2 * 2       100%
  7      location pointer   n/a   ButtonHW      6      1 * 2     2 * 2       2 * 2       100%
  8      location pointer   n/a   Button        7      1 * 2     2 * 2       2 * 2       100%
  -----  -----------------  ----  ------------  -----  --------  ----------  ----------  -----------
  Total                                         8      20        38          44          ~86%


Restricting system behavior using state/event exclusion plant invariants.

Preparing for MDD-based checks...
Analyzing automaton "Button"...
Analyzing automaton "Lamp"...
    Initializing the automaton data for event "Lamp.c_on"...
    Initializing the automaton data for event "Lamp.c_off"...
    Processing edges from location "Off" of automaton "Lamp"...
    Processing edges from location "On" of automaton "Lamp"...
    Updating global guards and updates for event "Lamp.c_on"...
    Updating global guards and updates for event "Lamp.c_off"...
Analyzing automaton "Timer"...
    Initializing the automaton data for event "Timer.c_start"...
    Processing edges from location "Idle" of automaton "Timer"...
    Processing edges from location "Running" of automaton "Timer"...
    Updating global guards and updates for event "Timer.c_start"...
Analyzing automaton "Cycle"...
    Initializing the automaton data for event "Lamp.c_on"...
    Initializing the automaton data for event "Timer.c_start"...
    Initializing the automaton data for event "Lamp.c_off"...
    Processing edges from location "WaitForButtonPush" of automaton "Cycle"...
    Processing edges from location "TurnLampOn" of automaton "Cycle"...
    Processing edges from location "StartTimer" of automaton "Cycle"...
    Processing edges from location "WaitForTimeout" of automaton "Cycle"...
    Processing edges from location "TurnLampOff" of automaton "Cycle"...
    Updating global guards and updates for event "Lamp.c_on"...
    Updating global guards and updates for event "Timer.c_start"...
    Updating global guards and updates for event "Lamp.c_off"...
Analyzing automaton "sup"...
    Initializing the automaton data for event "Lamp.c_on"...
    Initializing the automaton data for event "Lamp.c_off"...
    Initializing the automaton data for event "Timer.c_start"...
    Processing edges from the location of automaton "sup"...
    Updating global guards and updates for event "Lamp.c_on"...
    Updating global guards and updates for event "Lamp.c_off"...
    Updating global guards and updates for event "Timer.c_start"...
Analyzing automaton "ButtonHW"...
Analyzing automaton "LampHW"...
    Initializing the automaton data for event "Lamp.c_on"...
    Initializing the automaton data for event "Lamp.c_off"...
    Processing edges from location "Off" of automaton "LampHW"...
    Processing edges from location "On" of automaton "LampHW"...
    Updating global guards and updates for event "Lamp.c_on"...
    Updating global guards and updates for event "Lamp.c_off"...

Checking for bounded response...
Computing reachable states...
Reachable states: not LampHW.bit and (LampHW.Off and Lamp.Off) and (Timer.Idle and Cycle.WaitForButtonPush and (ButtonHW.Released and Button.Released)) [initial states predicate]
Forward reachability: iteration 1.
Reachable states: not LampHW.bit and (LampHW.Off and Lamp.Off) and (Timer.Idle and Cycle.WaitForButtonPush and (ButtonHW.Released and Button.Released)) -> <bdd 14n 2p> [forward reach with edge: (event: Button.u_pushed) (guard: (Cycle.WaitForButtonPush or Cycle.TurnLampOff) and ButtonHW.bit and (ButtonHW.Released and Button.Released) or (Cycle.StartTimer and ButtonHW.bit and (ButtonHW.Released and Button.Released) or (Cycle.TurnLampOn or Cycle.WaitForTimeout) and ButtonHW.bit and (ButtonHW.Released and Button.Released))) (assignments: Button := Button.Pushed, Cycle := Cycle.TurnLampOn, ButtonHW := ButtonHW.Pushed / Button := Button.Pushed, ButtonHW := ButtonHW.Pushed / Button := Button.Pushed, ButtonHW := ButtonHW.Pushed / Button := Button.Pushed, ButtonHW := ButtonHW.Pushed / Button := Button.Pushed, ButtonHW := ButtonHW.Pushed)]
Reachable states: <bdd 14n 2p> -> <bdd 19n 3p> [forward reach with edge: (event: Lamp.c_on) (guard: LampHW.Off and (Lamp.Off and Cycle.TurnLampOn)) (assignments: Lamp := Lamp.On, Cycle := Cycle.StartTimer, LampHW.bit := true, LampHW := LampHW.On)]
Reachable states: <bdd 19n 3p> -> <bdd 20n 4p> [forward reach with edge: (event: Timer.c_start) (guard: Timer.Idle and Cycle.StartTimer) (assignments: Timer := Timer.Running, Cycle := Cycle.WaitForTimeout)]
Reachable states: <bdd 20n 4p> -> <bdd 22n 5p> [forward reach with edge: (event: Timer.u_timeout) (guard: Timer.Running and Cycle.WaitForTimeout) (assignments: Timer := Timer.Idle, Cycle := Cycle.TurnLampOff)]
Reachable states: <bdd 22n 5p> -> <bdd 21n 5p> [forward reach with edge: (event: ButtonHW.bit) (guard: true) (assignments: ButtonHW.bit+ != ButtonHW.bit)]
Forward reachability: iteration 2.
Reachable states: <bdd 21n 5p> -> <bdd 23n 13p> [forward reach with edge: (event: Button.u_released) (guard: not ButtonHW.bit and (ButtonHW.Pushed and Button.Pushed)) (assignments: Button := Button.Released, ButtonHW := ButtonHW.Released)]
Reachable states: <bdd 23n 13p> -> <bdd 22n 14p> [forward reach with edge: (event: Lamp.c_off) (guard: LampHW.On and (Lamp.On and Cycle.TurnLampOff)) (assignments: Lamp := Lamp.Off, Cycle := Cycle.WaitForButtonPush, LampHW.bit := false, LampHW := LampHW.Off)]
Reachable states: <bdd 22n 14p> -> <bdd 17n 8p> [forward reach with edge: (event: ButtonHW.bit) (guard: true) (assignments: ButtonHW.bit+ != ButtonHW.bit)]
Forward reachability: iteration 3.
Reachable states: <bdd 17n 8p> [fixed point].

Computing bound for uncontrollable events...
Bounded response check round 1 (states before round: <bdd 17n 8p>).
Bounded response check round 2 (states before round: <bdd 24n 9p>).
Bounded response check round 3 (states before round: <bdd 12n 2p>).

Computing bound for controllable events...
Bounded response check round 1 (states before round: <bdd 17n 8p>).
Bounded response check round 2 (states before round: <bdd 16n 6p>).
Bounded response check round 3 (states before round: LampHW.bit and (LampHW.On and Lamp.On) and (Timer.Running and Cycle.WaitForTimeout and (ButtonHW.Released and Button.Released)) or LampHW.bit and (LampHW.On and Lamp.On) and (Timer.Running and Cycle.WaitForTimeout and (ButtonHW.Pushed and Button.Pushed))).

Bounded response check completed.

Checking for finite response...

Iteration 1.
    The following events have been encountered in a controllable-event loop of automaton Lamp:
        (Lamp.c_on Lamp.c_off), which is not controllable unconnectable.

Checking for confluence...

Mutual exclusive event pairs:
    (Lamp.c_off, Lamp.c_on), (Lamp.c_off, Timer.c_start), (Lamp.c_on, Timer.c_start)

CONCLUSION:
    [OK] The specification has bounded response:
    
        - A sequence of at most 2 transitions is possible for uncontrollable events.
        - A sequence of at most 2 transitions is possible for controllable events.

    [OK] The specification has finite response.
    [OK] The specification has confluence.

The model with the check results has been written to "controllercheck/bounded_response/bounded_button_lamp_timer_sup_hw.BCF.out.cif.real".
