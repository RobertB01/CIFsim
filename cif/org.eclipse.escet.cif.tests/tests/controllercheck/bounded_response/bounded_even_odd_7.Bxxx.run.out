Loading CIF specification "controllercheck/bounded_response/bounded_even_odd_7.cif".
Preparing for BDD-based checks:
    CIF variables and location pointers:
        Nr     Kind               Type        Name       Group  BDD vars  CIF values  BDD values  Values used
        -----  -----------------  ----------  ---------  -----  --------  ----------  ----------  -----------
        1      discrete variable  int[0..25]  p.counter  0      5 * 2     26 * 2      32 * 2      ~81%
        -----  -----------------  ----------  ---------  -----  --------  ----------  ----------  -----------
        Total                                            1      10        52          64          ~81%

    Skipping variable ordering: only one variable present.

    Restricting system behavior using state/event exclusion plant invariants:
        No guards changed.

Checking for bounded response:
    Computing reachable states:
        Reachable states: p.counter = 7 [initial states predicate]

        Forward reachability iteration 1:
            Reachable states: p.counter = 7 -> p.counter = 8 or p.counter = 7 [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter = 8 or p.counter = 7 -> p.counter = 8 or (p.counter = 6 or p.counter = 7) [forward reach with edge: (event: u_dec_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 9 or p.counter = 11)) or (p.counter = 13 or (p.counter = 15 or p.counter = 17) or (p.counter = 19 or p.counter = 21 or (p.counter = 23 or p.counter = 25)))) (assignments: p.counter := p.counter - 1)]
            Reachable states: p.counter = 8 or (p.counter = 6 or p.counter = 7) -> p.counter = 8 or p.counter = 9 or (p.counter = 6 or p.counter = 7) [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter = 8 or p.counter = 9 or (p.counter = 6 or p.counter = 7) -> p.counter = 8 or p.counter = 6 or (p.counter = 9 or (p.counter = 5 or p.counter = 7)) [forward reach with edge: (event: c_dec_even) (guard: p.counter = 16 or (p.counter = 8 or p.counter = 24) or (p.counter = 4 or (p.counter = 12 or p.counter = 20)) or (p.counter = 2 or (p.counter = 6 or p.counter = 10) or (p.counter = 14 or (p.counter = 18 or p.counter = 22)))) (assignments: p.counter := p.counter - 1)]

        Forward reachability iteration 2:
            Reachable states: p.counter = 8 or p.counter = 6 or (p.counter = 9 or (p.counter = 5 or p.counter = 7)) -> p.counter = 8 or (p.counter = 10 or p.counter = 6) or (p.counter = 9 or (p.counter = 5 or p.counter = 7)) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter = 8 or (p.counter = 10 or p.counter = 6) or (p.counter = 9 or (p.counter = 5 or p.counter = 7)) -> p.counter = 8 or (p.counter = 10 or p.counter = 4) or (p.counter = 6 or p.counter = 9 or (p.counter = 5 or p.counter = 7)) [forward reach with edge: (event: u_dec_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 9 or p.counter = 11)) or (p.counter = 13 or (p.counter = 15 or p.counter = 17) or (p.counter = 19 or p.counter = 21 or (p.counter = 23 or p.counter = 25)))) (assignments: p.counter := p.counter - 1)]
            Reachable states: p.counter = 8 or (p.counter = 10 or p.counter = 4) or (p.counter = 6 or p.counter = 9 or (p.counter = 5 or p.counter = 7)) -> 8 <= p.counter and p.counter <= 11 or 4 <= p.counter and p.counter <= 7 [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: 8 <= p.counter and p.counter <= 11 or 4 <= p.counter and p.counter <= 7 -> p.counter = 8 or p.counter = 10 or (p.counter = 4 or p.counter = 6) or (p.counter = 9 or p.counter = 5 or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) [forward reach with edge: (event: c_dec_even) (guard: p.counter = 16 or (p.counter = 8 or p.counter = 24) or (p.counter = 4 or (p.counter = 12 or p.counter = 20)) or (p.counter = 2 or (p.counter = 6 or p.counter = 10) or (p.counter = 14 or (p.counter = 18 or p.counter = 22)))) (assignments: p.counter := p.counter - 1)]

        Forward reachability iteration 3:
            Reachable states: p.counter = 8 or p.counter = 10 or (p.counter = 4 or p.counter = 6) or (p.counter = 9 or p.counter = 5 or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) -> p.counter = 8 or p.counter = 4 or (p.counter = 12 or (p.counter = 10 or p.counter = 6)) or (p.counter = 9 or p.counter = 5 or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter = 8 or p.counter = 4 or (p.counter = 12 or (p.counter = 10 or p.counter = 6)) or (p.counter = 9 or p.counter = 5 or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) -> p.counter = 8 or p.counter = 4 or (p.counter = 12 or (p.counter = 2 or p.counter = 10)) or (p.counter = 6 or (p.counter = 9 or p.counter = 5) or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) [forward reach with edge: (event: u_dec_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 9 or p.counter = 11)) or (p.counter = 13 or (p.counter = 15 or p.counter = 17) or (p.counter = 19 or p.counter = 21 or (p.counter = 23 or p.counter = 25)))) (assignments: p.counter := p.counter - 1)]
            Reachable states: p.counter = 8 or p.counter = 4 or (p.counter = 12 or (p.counter = 2 or p.counter = 10)) or (p.counter = 6 or (p.counter = 9 or p.counter = 5) or (p.counter = 3 or (p.counter = 11 or p.counter = 7))) -> p.counter = 8 or (p.counter = 9 or p.counter = 4) or (p.counter = 5 or (p.counter = 12 or p.counter = 13)) or (p.counter = 2 or (p.counter = 3 or p.counter = 10) or (p.counter = 11 or (p.counter = 6 or p.counter = 7))) [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter = 8 or (p.counter = 9 or p.counter = 4) or (p.counter = 5 or (p.counter = 12 or p.counter = 13)) or (p.counter = 2 or (p.counter = 3 or p.counter = 10) or (p.counter = 11 or (p.counter = 6 or p.counter = 7))) -> p.counter = 8 or (p.counter = 4 or p.counter = 12) or (p.counter = 2 or (p.counter = 10 or p.counter = 6)) or (p.counter = 1 or (p.counter = 5 or p.counter = 9) or (p.counter = 13 or p.counter = 3 or (p.counter = 11 or p.counter = 7))) [forward reach with edge: (event: c_dec_even) (guard: p.counter = 16 or (p.counter = 8 or p.counter = 24) or (p.counter = 4 or (p.counter = 12 or p.counter = 20)) or (p.counter = 2 or (p.counter = 6 or p.counter = 10) or (p.counter = 14 or (p.counter = 18 or p.counter = 22)))) (assignments: p.counter := p.counter - 1)]

        Forward reachability iteration 4:
            Reachable states: p.counter = 8 or (p.counter = 4 or p.counter = 12) or (p.counter = 2 or (p.counter = 10 or p.counter = 6)) or (p.counter = 1 or (p.counter = 5 or p.counter = 9) or (p.counter = 13 or p.counter = 3 or (p.counter = 11 or p.counter = 7))) -> not(p.counter = 0 or p.counter = 16) and p.counter != 24 and (p.counter != 20 and not(p.counter = 18 or p.counter = 22)) and (not(p.counter = 17 or (p.counter = 21 or p.counter = 25)) and p.counter != 19 and (p.counter != 23 and p.counter != 15)) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: not(p.counter = 0 or p.counter = 16) and p.counter != 24 and (p.counter != 20 and not(p.counter = 18 or p.counter = 22)) and (not(p.counter = 17 or (p.counter = 21 or p.counter = 25)) and p.counter != 19 and (p.counter != 23 and p.counter != 15)) -> not(p.counter = 16 or p.counter = 18 or (p.counter = 20 or (p.counter = 22 or p.counter = 24))) and not(p.counter = 17 or (p.counter = 21 or p.counter = 25)) and (p.counter != 19 and (p.counter != 23 and p.counter != 15)) [forward reach with edge: (event: u_dec_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 9 or p.counter = 11)) or (p.counter = 13 or (p.counter = 15 or p.counter = 17) or (p.counter = 19 or p.counter = 21 or (p.counter = 23 or p.counter = 25)))) (assignments: p.counter := p.counter - 1)]
            Reachable states: not(p.counter = 16 or p.counter = 18 or (p.counter = 20 or (p.counter = 22 or p.counter = 24))) and not(p.counter = 17 or (p.counter = 21 or p.counter = 25)) and (p.counter != 19 and (p.counter != 23 and p.counter != 15)) -> 0 <= p.counter and p.counter <= 15 [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 5:
            Reachable states: 0 <= p.counter and p.counter <= 15 -> p.counter != 24 and p.counter != 20 and (not(p.counter = 18 or p.counter = 22) and (0 <= p.counter and p.counter <= 16 or p.counter = 18 or (p.counter = 20 or (p.counter = 22 or p.counter = 24)))) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter != 24 and p.counter != 20 and (not(p.counter = 18 or p.counter = 22) and (0 <= p.counter and p.counter <= 16 or p.counter = 18 or (p.counter = 20 or (p.counter = 22 or p.counter = 24)))) -> 0 <= p.counter and p.counter <= 23 and (not(p.counter = 20 or p.counter = 21) and not(p.counter = 18 or p.counter = 19 or (p.counter = 22 or p.counter = 23))) [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 6:
            Reachable states: 0 <= p.counter and p.counter <= 23 and (not(p.counter = 20 or p.counter = 21) and not(p.counter = 18 or p.counter = 19 or (p.counter = 22 or p.counter = 23))) -> p.counter != 24 and not(p.counter = 20 or p.counter = 22) and (p.counter != 25 and (p.counter != 21 and not(p.counter = 19 or p.counter = 23))) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter != 24 and not(p.counter = 20 or p.counter = 22) and (p.counter != 25 and (p.counter != 21 and not(p.counter = 19 or p.counter = 23))) -> 0 <= p.counter and (p.counter <= 23 and not(20 <= p.counter and p.counter <= 23)) [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 7:
            Reachable states: 0 <= p.counter and (p.counter <= 23 and not(20 <= p.counter and p.counter <= 23)) -> p.counter != 24 and p.counter != 22 and (p.counter != 25 and not(p.counter = 21 or p.counter = 23)) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter != 24 and p.counter != 22 and (p.counter != 25 and not(p.counter = 21 or p.counter = 23)) -> 0 <= p.counter and (p.counter <= 23 and not(p.counter = 22 or p.counter = 23)) [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 8:
            Reachable states: 0 <= p.counter and (p.counter <= 23 and not(p.counter = 22 or p.counter = 23)) -> p.counter != 24 and (p.counter != 25 and p.counter != 23) [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter != 24 and (p.counter != 25 and p.counter != 23) -> 0 <= p.counter and p.counter <= 23 [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 9:
            Reachable states: 0 <= p.counter and p.counter <= 23 -> p.counter != 25 [forward reach with edge: (event: u_inc_odd) (guard: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 17 or p.counter = 19)) or (p.counter = 21 or (p.counter = 23 or p.counter = 9) or (p.counter = 11 or (p.counter = 13 or p.counter = 15)))) (assignments: p.counter := p.counter + 1)]
            Reachable states: p.counter != 25 -> true [forward reach with edge: (event: c_inc_even) (guard: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))) (assignments: p.counter := p.counter + 1)]

        Forward reachability iteration 10:
            No change this iteration.

        Reachable states: true [fixed point].

    Computing bound for uncontrollable events:
        Bounded response check round 1 (states before round: true).
        Bounded response check round 2 (states before round: p.counter = 0 or (p.counter = 2 or p.counter = 4) or (p.counter = 6 or (p.counter = 8 or p.counter = 10)) or (p.counter = 12 or (p.counter = 14 or p.counter = 16) or (p.counter = 18 or p.counter = 20 or (p.counter = 22 or p.counter = 24)))).

        Bound: 1.

    Computing bound for controllable events:
        Bounded response check round 1 (states before round: true).
        Bounded response check round 2 (states before round: p.counter = 1 or (p.counter = 3 or p.counter = 5) or (p.counter = 7 or (p.counter = 9 or p.counter = 11)) or (p.counter = 13 or (p.counter = 15 or p.counter = 17) or (p.counter = 19 or p.counter = 21 or (p.counter = 23 or p.counter = 25)))).

        Bound: 1.

    Bounded response check completed.

CONCLUSION:
    [OK] The specification has bounded response:

        - A sequence of at most 1 transition is possible for uncontrollable events.
        - A sequence of at most 1 transition is possible for controllable events.

    [UNKNOWN] Non-blocking under control checking was disabled, non-blocking under control property is unknown.
    [UNKNOWN] Finite response checking was disabled, finite response property is unknown.
    [UNKNOWN] Confluence checking was disabled, confluence property is unknown.

The model with the check results has been written to "controllercheck/bounded_response/bounded_even_odd_7.Bxxx.out.cif.real".
