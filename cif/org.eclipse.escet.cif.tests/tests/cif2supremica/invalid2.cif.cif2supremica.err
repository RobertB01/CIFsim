ERROR: CIF to Supremica transformation failed due to unsatisfied preconditions:
 - A 'time' variable reference is used:
   - In location "p.l":
     - edge u do r := time;
                      ^
 - A dictionary literal is used:
   - In discrete variable "p.dbb":
     - disc dict(bool:bool) dbb = {true: false};
                                  ^
   - In location "p.l":
     - edge u do dbb := {true: true};
                        ^
 - A dictionary type is used:
   - In discrete variable "p.dbb":
     - disc dict(bool:bool) dbb = {true: false};
            ^                     ^
   - In location "p.l":
     - edge u do dbb := {true: true};
                 ^      ^
 - A distribution type is used:
   - In discrete variable "p.db":
     - disc dist bool db = constant(true);
            ^              ^       ^
   - In location "p.l":
     - edge u do (b, db) := sample db;
                 ^   ^      ^      ^
 - A function call is used:
   - In discrete variable "p.db":
     - disc dist bool db = constant(true);
                                   ^
 - A function type is used:
   - In discrete variable "p.db":
     - disc dist bool db = constant(true);
                           ^
   - In discrete variable "p.fbb":
     - disc func bool(bool) fbb = f;
            ^                     ^
   - In location "p.l":
     - edge u do fbb := f;
                 ^      ^
 - A list literal is used:
   - In discrete variable "p.lb":
     - disc list bool lb = [true];
                           ^
 - A list type is used:
   - In location "p.l":
     - edge u do lb := lb[:];
                 ^     ^ ^
   - In discrete variable "p.lb":
     - disc list bool lb = [true];
            ^              ^
 - A projection expression is used:
   - In location "p.l":
     - edge u do tbb[a] := true;
                    ^
 - A rangeless integer type is used:
   - In discrete variable "p.i":
     - disc int i;
            ^
   - In location "p.l":
     - edge u do i := if true: 1 else 2 end;
                 ^
     - edge u do i := switch 1: else 2 end;
                 ^
     - edge u do i := switch p: case l: 3 end;
                 ^
     - edge u do i := i div i;
                 ^    ^ ^   ^
     - edge u do i := i mod i;
                 ^    ^ ^   ^
     - edge u do b := i < i;
                      ^   ^
     - edge u do b := i <= i;
                      ^    ^
     - edge u do b := i > i;
                      ^   ^
     - edge u do b := i >= i;
                      ^    ^
     - edge u do i := +i;
                 ^    ^^
     - edge u do i := -i;
                 ^    ^^
 - A real number literal is used:
   - In location "p.l":
     - edge u do r := <real>1.0;
                            ^
   - In discrete variable "p.r":
     - disc real r = 1.2;
                     ^
 - A real type is used:
   - In location "p.l":
     - edge u do r := <real>1;
                 ^     ^
     - edge u do r := <real>1.0;
                 ^     ^    ^
     - edge u do r := time;
                 ^    ^
     - edge u do r := r + r;
                 ^    ^ ^ ^
     - edge u do r := r - r;
                 ^    ^ ^ ^
     - edge u do r := r * r;
                 ^    ^ ^ ^
     - edge u do r := r / r;
                 ^    ^ ^ ^
   - In discrete variable "p.r":
     - disc real r = 1.2;
            ^        ^
 - A set literal is used:
   - In location "p.l":
     - edge u do sb := {true} or {false};
                       ^         ^
     - edge u do sb := {true} and {false};
                       ^          ^
   - In discrete variable "p.sb":
     - disc set bool sb = {true};
                          ^
 - A set type is used:
   - In location "p.l":
     - edge u do sb := {true} or {false};
                 ^     ^      ^  ^
     - edge u do sb := {true} and {false};
                 ^     ^      ^   ^
     - edge u do b := true in sb;
                              ^
     - edge u do b := sb sub sb;
                      ^      ^
   - In discrete variable "p.sb":
     - disc set bool sb = {true};
            ^             ^
 - A slice expression is used:
   - In location "p.l":
     - edge u do lb := lb[:];
                         ^
 - A string literal is used:
   - In location "p.l":
     - edge u do str := "a";
                        ^
   - In discrete variable "p.str":
     - disc string str = "a";
                         ^
 - A string type is used:
   - In location "p.l":
     - edge u do str := "a";
                 ^      ^
   - In discrete variable "p.str":
     - disc string str = "a";
            ^            ^
 - A switch expression is used:
   - In location "p.l":
     - edge u do i := switch 1: else 2 end;
                      ^
     - edge u do i := switch p: case l: 3 end;
                      ^
 - A tuple literal is used:
   - In location "p.l":
     - edge u do (b, db) := sample db;
                 ^
   - In discrete variable "p.tbb":
     - disc tuple(bool a; bool b) tbb = (true, false);
                                        ^
 - A tuple type is used:
   - In location "p.l":
     - edge u do tbb[a] := true;
                 ^
     - edge u do (b, db) := sample db;
                 ^          ^
   - In discrete variable "p.tbb":
     - disc tuple(bool a; bool b) tbb = (true, false);
            ^                           ^
 - A type-changing cast expression is used:
   - In location "p.l":
     - edge u do r := <real>1;
                      ^
 - An 'if' expression is used:
   - In location "p.l":
     - edge u do i := if true: 1 else 2 end;
                      ^
 - Binary operator "*" is used on a real typed operand:
   - In location "p.l":
     - edge u do r := r * r;
                        ^
 - Binary operator "+" is used on a real typed operand:
   - In location "p.l":
     - edge u do r := r + r;
                        ^
 - Binary operator "-" is used on a real typed operand:
   - In location "p.l":
     - edge u do r := r - r;
                        ^
 - Binary operator "/" is used:
   - In location "p.l":
     - edge u do r := r / r;
                        ^
 - Binary operator "<" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do b := i < i;
                        ^
 - Binary operator "<=" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do b := i <= i;
                        ^
 - Binary operator ">" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do b := i > i;
                        ^
 - Binary operator ">=" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do b := i >= i;
                        ^
 - Binary operator "and" is used on a set typed operand:
   - In location "p.l":
     - edge u do sb := {true} and {false};
                              ^
 - Binary operator "div" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do i := i div i;
                        ^
 - Binary operator "in" is used:
   - In location "p.l":
     - edge u do b := true in sb;
                           ^
 - Binary operator "mod" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do i := i mod i;
                        ^
 - Binary operator "or" is used on a set typed operand:
   - In location "p.l":
     - edge u do sb := {true} or {false};
                              ^
 - Binary operator "sub" is used:
   - In location "p.l":
     - edge u do b := sb sub sb;
                         ^
 - Edge has a multi-assignment:
   - In location "p.l":
     - edge u do (b, db) := sample db;
                         ^
 - Edge has a partial variable assignment:
   - In location "p.l":
     - edge u do tbb[a] := true;
                        ^
 - Function is a user-defined function:
   - In the top-level scope of the specification:
     - func bool f(bool p):
                 ^
 - Invariant is a state invariant in a location:
   - In location "p.l":
     - plant invariant b;
                       ^
 - Unary operator "+" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do i := +i;
                      ^
 - Unary operator "-" is used on a rangeless integer typed operand:
   - In location "p.l":
     - edge u do i := -i;
                      ^
 - Unary operator "sample" is used:
   - In location "p.l":
     - edge u do (b, db) := sample db;
                            ^
