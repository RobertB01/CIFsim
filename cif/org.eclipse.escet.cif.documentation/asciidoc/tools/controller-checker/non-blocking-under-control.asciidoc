//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
//////////////////////////////////////////////////////////////////////////////

include::../_part_attributes.asciidoc[]

[[tools-controller-checker-non-blocking-under-control]]
== Non-blocking under control check

The <<tools-chapter-controller-checker,controller properties checker>> can check a <<sbe-approaches-synthesis-based-supervisor-vs-controller,supervisor>> for being non-blocking under control.

The non-blocking under control property holds if a <<lang-tut-extensions-synthesis-marked,marked>> state can be reached, even though the transitions for uncontrollable events and controllable events are executed in a specific way in code generated from the supervisor.
This property ensures that the code is still non-blocking, and that the <<sbe-approaches-synthesis-based-non-blocking,non-blockingness guarantee of synthesis>> is thus preserved in generated code.

Concretely, the check verifies that for every reachable state, there exists a path to a marked state, with no controllable events enabled in the last/marked state of the path, and all transitions on the path are either for controllable events, or for uncontrollable ones from states where no controllable events are enabled.

=== Examples

For example, for the `Supervisor1` automaton in the example below the non-blocking under control property does _not_ hold.
All locations are reachable.
And if `c_act1` is done first, before `c_act2`, the automaton goes through marked location `Done1`.
But, if instead `c_act2` is done first, before `c_act1`, the automaton does not go through a marked location.
And if the every time the choice is made to first do `c_act2` and only then `c_act1`, the automaton never goes through a marked location.

[source, cif]
----
supervisor Supervisor1:
  controllable c_act1, c_act2;
  uncontrollable u_button_pushed;

  location Start:
    initial;
    edge c_act1 goto Done1;
    edge c_act2 goto Done2;

  location Done1:
    marked;
    edge c_act2 goto BothDone;

  location Done2:
    edge c_act1 goto BothDone;

  location BothDone:
    edge u_button_pushed goto Start;
end
----

A version of this supervisor that is non-blocking under control would have the marked location at the end of controllable event path, like so:

[source, cif]
----
supervisor Supervisor1:
  controllable c_act1, c_act2;
  uncontrollable u_button_pushed;

  location Start:
    initial;
    edge c_act1 goto Done1;
    edge c_act2 goto Done2;

  location Done1:
    edge c_act2 goto BothDone;

  location Done2:
    edge c_act1 goto BothDone;

  location BothDone:
    marked;
    edge u_button_pushed goto Start;
end
----

As another example, consider the `Supervisor2` automaton below, for which also the non-blocking under control does _not_ hold.
Here too, all locations are reachable.
But, if first `c_act1` is done, then `c_act2`, and finally `u_button_pusehd`, then it cycles without going through a marked location.
A marked location can be reached, by doing `u_button_pushed` in location `Done1`.
But, in the generated code first all transitions for uncontrollable events are executed, and then the transitions for controllable events.
In `Start`, no uncontrollable event is possible.
And after doing `c_act` the code will keep doing transitions for controllable events, opting for `c_act2` rather than `u_button_pushed`.
Hence, a marked state can never be reached in the generated code.

[source, cif]
----
supervisor Supervisor2:
  controllable c_act1, c_act2;
  uncontrollable u_button_pushed;

  location Start:
    initial;
    edge c_act1 goto Done1;

  location Done1:
    edge c_act2 goto BothDone;
    edge u_button_pushed goto Halt;

  location BothDone:
    edge u_button_pushed goto Start;

  location Halt:
    marked;
end
----

A version of this supervisor that is non-blocking under control would have the marked location at the end of controllable event path, and would not have a deadlock state, like so:

[source, cif]
----
supervisor Supervisor2:
  controllable c_act1, c_act2;
  uncontrollable u_button_pushed;

  location Start:
    initial;
    edge c_act1 goto Done1;

  location Done1:
    edge c_act2 goto BothDone;

  location BothDone:
    marked;
    edge u_button_pushed goto Start;
end
----

=== Implementation details

Non-blocking under control for a model is determined as follows:

* Compute predicate _gc_ that indicates in which states a controllable event is enabled in the system.
This is computed by taking the disjunction of the guards of the edges labeled with controllable events.
* Compute predicate _not gc_ that indicates in which states no controllable events are enabled in the system.
This is computed by taking the inverse of _gc_.
* Compute the _ccp_ states, the states on controllable-complete paths.
This is computed by performing a backwards reachability computation from _marked and not gc_, using all edges labeled with controllable and uncontrollable events, but not edges that allow input variables to change value.
During this reachability computation, for each edge labeled with an uncontrollable event, _guard and not gc_ is used instead of its original _guard_.
* Compute the _bad_ states, the not-_ccp_ states and states that can reach such states.
This is computed by performing a backwards reachability computation on _not ccp_, using all edges labeled with controllable and uncontrollable events, but not edges that allow input variables to change value.
Unlike in the previous step, the original guards are used for all edges during this reachability computation.
* The model is non-blocking under control if the _initial_ states are not _bad_.
That is, the model is non-blocking under control check if _(initial and bad) = false_ holds.

This algorithm is based on <<reijnen19>>.
