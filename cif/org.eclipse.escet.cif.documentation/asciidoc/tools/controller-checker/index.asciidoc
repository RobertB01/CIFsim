//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021, 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
//////////////////////////////////////////////////////////////////////////////

include::../_part_attributes.asciidoc[]

[[tools-chapter-controller-checker]]
== Controller properties checker

indexterm:[controller properties checker]
indexterm:[tools,controller properties checker]
The controller properties checker can be used to determine whether a <<sbe-approaches-synthesis-based-supervisor-vs-controller,supervisor>> to be implemented as a <<sbe-approaches-synthesis-based-supervisor-vs-controller,controller>> satisfies certain desired properties.
These properties are not yet guaranteed through <<sbe-approaches-synthesis-synthesis,synthesis>>, and must therefore be checked on a synthesized supervisor, before <<sbe-in-practice-steps-implementation,code is generated>> from it.

The controller properties checker assume a certain structure of code generated by code generators:

* Some code for the model is executed, and after a fixed or variable time, the code is executed again, and so on.
* Every time the code is executed:
** First the external inputs are read.
** Then transitions for <<sbe-approaches-synthesis-based-events,uncontrollable events>> are executed to update the state based on the inputs.
** Then transitions for <<sbe-approaches-synthesis-based-events,controllable events>> are executed to compute the control response, and update the state to reflect it.
** And finally, the external outputs are written.

The controller checker can check the following properties:

<<tools-controller-checker-confluence,Confluence>>::
The confluence property holds if for each execution of the controllable events, it does not matter in which order the controllable events are executed, as the same state is reached regardless.
This property ensures that if the code generator makes a choice to execute events in a certain order, this does not affect the <<sbe-approaches-synthesis-based-properties,guarantees of synthesis>>.
In other words, it does not matter which transitions for controllable event are chosen and in which order, as the end result is the same.
+
This check does not check for confluence of the uncontrollable events.
Furthermore, the check may produce false negatives.
+
Read more about this check on the <<tools-controller-checker-confluence,confluence check>> page.

<<tools-controller-checker-finite-response,Finite response>>::
The finite response property holds if for each execution of the code, the number of controllable events to execute is finite.
This property ensures that the code that executes the controllable events always terminates.
That is, the system has no loops with only controllable events.
In other words, there is no <<lang-tut-time-livelock,livelock>> for controllable events.
+
This check does not check for finite response of the uncontrollable events.
Furthermore, the check may produce false negatives.
+
Read more about this check on the <<tools-controller-checker-finite-response,finite response check>> page.

indexterm:[controller properties checker,start]

=== Starting the checker

The checker can be started in the following ways:

* In Eclipse, right click a `.cif` file in the _Project Explorer_ tab or _Package Explorer_ tab and choose menu:CIF simulation, validation and verification tools[Apply controller checks...].

* In Eclipse, right click an open text editor for a `.cif` file and choose menu:CIF simulation, validation and verification tools[Apply controller checks...].

* Use the `cifcontrollercheck` tool in a ToolDef script.
See the <<tools-scripting-chapter-intro,scripting documentation>> and <<tools-scripting-chapter-tools,tools overview>> page for details.

* Use the `cifcontrollercheck` command line tool.

indexterm:[controller properties checker,options]

[[tools-controller-checker-options]]
=== Options

Besides the general application options, this application has the following options:

* _Input file path_: The absolute or relative file system path to the input CIF specification.

* _Enable confluence checking_: If set (the default), confluence is checked in the CIF specification.
If unset, confluence checking is not performed.

* _Enable finite response checking_: If set (the default), finite response is checked in the CIF specification.
If unset, finite response checking is not performed.

* _Print control loops_: If set (the default), during finite response checking the events that may still occur in a controllable-event loop are printed to the console.

At least one of the checks must be enabled.

indexterm:[controller properties checker,supported specifications]

=== Supported specifications

The CIF controller properties checker supports a subset of CIF specifications.
The following restrictions apply:

* Channels (events with data types) are not supported.

* Continuous variables are not supported.

* Only plant and supervisor invariants are supported.
Kindless and requirement invariants are not supported.

* State invariants are not supported, unless they are trivially `true`.

* Functions are not supported.

* Events not declared as controllable or uncontrollable are not supported.
  This includes the ``tau`` event, both explicitly used on edges, as well as implicitly for edges without explicitly mentioned events.

* Multi-assignments on edges (such as ``do (x, y) := (1, 2)``) are not supported.
However, it is allowed to use multiple assignments on an edge (such as ``do x := 1, y := 2``).

* Only discrete/input variables with a boolean, ranged integer (e.g. ``int[0..5]``), or enumeration type are supported.

* Only the following expressions are supported: boolean literal values (``true`` and ``false``), integer literal values, enumeration literal values, binary expressions (partially, see below), unary expressions (partially, see below), casts that don't change the type, `if` expressions, `switch` expressions, and references to constants, discrete variables, input variables, algebraic variables, and locations.

* Only the following binary operators are supported: logical equivalence (`+<=>+`), logical implication (`+=>+`), logical conjunction (`and` on boolean operands), logical disjunction (`or` on boolean operands), addition (`+`) on integer operands, subtraction (`-`) on integer operands, multiplication (`*`) on integer operands, integer division (`div`), integer modulus (`mod`), equality (`=`) on integer, integer or enumeration operands, inequality (`!=`) on boolean, integer or enumeration operands, less than (`<`) on integer operands, less than or equal to (`+<=+`) on integer operands, greater than (`>`) on integer operands, and greater than or equal to (`>=`) on integer operands.

* Only the following unary operators are supported: logical inverse (`not`), negation (`-`) on an integer operand, and plus (`+`) on an integer operand.

* Only plant and supervisor automata are supported.
Kindless and requirement automata are not supported.

* Specifications without automata are not supported.

* Automata with non-determinism for controllable events are not supported.
That is, automata that have locations with multiple outgoing edges for the same controllable event, with overlapping guards (e.g. `x > 1` and `x < 4`), are not supported.
Note that this check may lead to false positives, as checks are an over-approximation and guard overlap may be detected for unreachable states.

* I/O declarations are ignored.
A warning is printed if a CIF/SVG input declaration is encountered.

* Annotations are ignored.

indexterm:[controller properties checker,preprocessing]

=== Preprocessing

The following <<tools-cif2cif-chapter-index,CIF to CIF transformations>> are applied as preprocessing (in the given order), to increase the subset of CIF specifications that can be checked:

* <<tools-cif2cif-chapter-remove-io-decls>>

* <<tools-cif2cif-chapter-elim-comp-def-inst>>

* <<tools-cif2cif-chapter-elim-state-event-excl-invs>>

* <<tools-cif2cif-chapter-elim-monitors>>

* <<tools-cif2cif-chapter-elim-self>>

* <<tools-cif2cif-chapter-elim-type-decls>>

* <<tools-cif2cif-chapter-elim-locs-in-exprs>>

* <<tools-cif2cif-chapter-enums-to-ints>>

* <<tools-cif2cif-chapter-elim-alg-vars>>

* <<tools-cif2cif-chapter-elim-consts>>

* <<tools-cif2cif-chapter-simplify-values>>

* <<tools-cif2cif-chapter-elim-if-updates>>

indexterm:[controller properties checker property,runtime errors]

[[tools-controller-checker-runtime-errors]]
=== Runtime errors

The model is assumed not to contain runtime errors, such as division by zero, modulus of zero, or assigning out of bounds values.
Since the checker silently discards any such behavior, the outcome of the various checks may be incorrect if the model exhibits behavior leading to runtime errors.

When PLC code is generated for models with runtime errors, the properties cannot be guaranteed as the resulting code may not behave as the CIF specification (see <<tools-cif2plc-generatedcode,generated code>>).

One way to get a model without runtime errors is to use supervisor synthesis, since that removes such behavior from its input.
For more information, see the <<tools-chapter-datasynth,data-based>> and <<tools-eventbased-chapter-supervisorsynthesis,event-based>> supervisor synthesis tools.
Alternatively, the <<tools-chapter-cif-explorer,CIF explorer>> may be used to verify that the specification does not contain runtime errors.

[bibliography]
=== References

* [[[reijnen19,Reijnen et al. (2019)]]] Ferdie F.H. Reijnen, Albert T. Hofkamp, Joanna M. van de Mortel-Fronczak, Michel A. Reniers and Jacobus E. Rooda, "Finite Response and Confluence of State-based Supervisory Controllers", In: Proceedings of the 15th International Conference on Automation Science and Engineering, pages 509-516, 2019, doi:link:https://doi.org/10.1109/COASE.2019.8843335[10.1109/COASE.2019.8843335]
