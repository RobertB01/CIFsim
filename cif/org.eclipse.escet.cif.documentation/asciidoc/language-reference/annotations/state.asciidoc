//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
//////////////////////////////////////////////////////////////////////////////

include::../_part_attributes.asciidoc[]

[[lang-ref-extensions-annotations-state]]
== State annotations

WARNING: Annotations are currently an experimental work-in-progress language feature.
Their design may change in a backward incompatible manner.

A state <<lang-ref-extensions-annotations,annotation>> adds <<lang-tut-basics-chapter-synchronizing-events-statespace,state>> information to a location in an automaton.
For basic information on state annotations, see the <<lang-tut-extensions-chapter-annotations-state,language tutorial>>.
Here we discuss further details.

State annotations (`@state`) can be added to the following elements in CIF specifications:

* Locations of automata.

The annotation has the following additional constraints, in addition to the <<lang-ref-extensions-annotations-constraints,general constraints>> that apply to all annotations:

* A single location may have multiple state annotations, if that location represents multiple states of a state space.
* Each argument of a state annotation represents either an automaton with its current location, or a variable with its current value.
* There can be any number of arguments (including no arguments), as models may have any number of automata and variables.
* The name of the argument must be the absolute name of the corresponding automaton or variable.
* Argument values, and parts of argument values (in case of containers), must be literals of type `bool`, `int`, `real`, `string`, `tuple`, `list`, `set`, or `dict`.
This implies that the values must be statically evaluable, and that evaluating an argument value must not result in an evaluation error.

Most values can thus be represented as literals.
For instance, boolean values are represented by boolean literals `true` or `false`, and a list of integers is represented by a list literal, such as `[1, 2, 3]`.
There are some exceptions:

[cols="1,4"]
|===
| Location / value | Represented as

| Location of an automaton
| String literal with the <<lang-ref-syntax-lexical-identifier,non-escaped>> name of the location, or `"*"` for a nameless location.

| Enumeration literal
| String literal with the <<lang-ref-syntax-lexical-identifier,non-escaped>> name of the enumeration literal.

| Function
| String literal with the <<lang-ref-syntax-lexical-identifier,non-escaped>> absolute name of the function, or `"*"` for functions that represent a default initial value of a variable with a function type.
|===
