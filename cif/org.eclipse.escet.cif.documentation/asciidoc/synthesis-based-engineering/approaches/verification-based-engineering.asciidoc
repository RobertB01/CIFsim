//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010, 2022 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
//////////////////////////////////////////////////////////////////////////////

include::../_part_attributes.asciidoc[]

indexterm:[engineering, verification-based]

[[sbe-approaches-verification-based]]
== Verification-based engineering

indexterm:[verification]

Verification-based engineering is a form of <<sbe-approaches-model-based,model-based engineering>>.
It uses formal verification to automate the verification that the controller model satisfies its requirements.

indexterm:[verification, formal]

Formal verification allows to mathematically prove a certain property, such as the absence of deadlock or livelock, or that bridge may only open if its corresponding traffic lights have been set to signal a red light.
Formal verification can prove that such properties hold for every conceivable scenario.
It is thus more powerful than testing, which is typically covers only a limited number of scenarios and is then not exhaustive.

indexterm:[counter example]

If a property does not hold, formal verification produces counter examples, typically in the form of a sequences of inputs that lead to states in the controller model where the property is not satisfied.
This makes it possible to pinpoint the problem in the model, and address it.
It is often an iterative process to address such issues, perform verification again, address more issues, perform verification again, etc.
If no counter examples are produced, all verified properties are satisfied by the controller model.

To employ formal verification not only the controller model must be formally specified, but also the properties to check.
This means that the requirements are no longer specified in natural language in documents, but in mathematically unambiguous specifications.
An example is state machines that define the order in which things may happen, such as that a certain sensor must go on before an actuator can be enabled.
Another example is logical formulas that indicate that certain combinations of states in the controller models should never occur, e.g., they could indicate a collision that is to be prevented.
