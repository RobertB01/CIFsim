//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010, 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
//////////////////////////////////////////////////////////////////////////////

package org.eclipse.escet.common.emf.ecore.codegen.java;

import static org.eclipse.escet.common.java.Lists.set2list;
import static org.eclipse.escet.common.java.Sets.set;
import static org.eclipse.escet.common.java.Strings.fmt;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EFactory;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.escet.common.box.CodeBox;
import org.eclipse.escet.common.box.MemoryCodeBox;
import org.eclipse.escet.common.java.Assert;
import org.eclipse.escet.common.java.JavaCodeUtils;
import org.eclipse.escet.common.java.Strings;

/**
 * EClass constructors Java class generator for Ecore models. Generates classes with static constructor methods that can
 * be used instead of the factory methods generated by EMF, resulting in much shorter code.
 */
public class EmfConstructorsGenerator extends EmfJavaCodeGenerator {
    /**
     * Application that can generate constructor code for all classes in the given {@link EPackage}, including all its
     * sub-packages (recursively).
     *
     * @param args Application arguments:
     *     <ul>
     *     <li>The full name of the main {@link EPackage} Java class. For instance, {@code
     *           "bla.somelang.metamodel.somelang.SomeLangPackage"}.</li>
     *     <li>The path to add to the Java class path to allow the main package Java class to be found. For instance,
     *     {@code "bin"}. It is allowed to add multiple paths. For instance, {@code "bin|../bin"}.</li>
     *     <li>The output directory path. For instance, {@code "src/bla/somelang/metamodel/java"}.</li>
     *     <li>The output class name. For instance, {@code "SomeLangConstructors"}.</li>
     *     <li>The output package name. For instance, {@code "bla.somelang.metamodel.java"}.</li>
     *     </ul>
     * @throws IOException In case the code could not be written to a file; or in case the java class path extension
     *     path is invalid.
     * @throws ClassNotFoundException If the class can not be found.
     * @throws NoSuchFieldException If the {@code eINSTANCE} field is not found in the class.
     * @throws IllegalAccessException If the {@code eINSTANCE} field is inaccessible.
     */
    public static void main(String[] args)
            throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException
    {
        // Process arguments.
        Assert.check(args.length == 5);
        String mainPkgClassName = args[0];
        String binPath = args[1];
        String outputPath = args[2];
        String outputClassName = args[3];
        String outputPackageName = args[4];

        // Resolve the package.
        EPackage mainPkg = loadEPackage(mainPkgClassName, binPath);

        // Generate code for the package.
        CodeBox box = generate(mainPkg, outputClassName, outputPackageName);

        // Try to write the code to a file.
        String outputFilePath = new File(new File(outputPath), outputClassName + ".java").getAbsolutePath();
        box.writeToFile(outputFilePath);

        // We are done.
        System.out.printf("Code written to: %s%n", outputFilePath);
    }

    /**
     * Generates constructor code for all classes in the given {@link EPackage}, including all its sub-packages
     * (recursively).
     *
     * @param pkg The {@link EPackage} to generate the code for.
     * @param genClassName The name of the Java class to generate.
     * @param genPackageName The name of the package that the generated Java class will be a part of.
     * @return The generated code.
     */
    private static CodeBox generate(EPackage pkg, String genClassName, String genPackageName) {
        CodeBox box = new MemoryCodeBox();

        List<EClass> classes = getClasses(pkg, true);
        List<EFactory> factories = getFactories(pkg);
        box.add("//////////////////////////////////////////////////////////////////////////////");
        box.add("// Copyright (c) 2010, 2024 Contributors to the Eclipse Foundation");
        box.add("//");
        box.add("// See the NOTICE file(s) distributed with this work for additional");
        box.add("// information regarding copyright ownership.");
        box.add("//");
        box.add("// This program and the accompanying materials are made available");
        box.add("// under the terms of the MIT License which is available at");
        box.add("// https://opensource.org/licenses/MIT");
        box.add("//");
        box.add("// SPDX-License-Identifier: MIT");
        box.add("//////////////////////////////////////////////////////////////////////////////");
        box.add();
        box.add("// Generated using the \"org.eclipse.escet.common.emf.ecore.codegen\" project.");
        box.add();
        box.add("// Disable Eclipse Java formatter for generated code file:");
        box.add("// @formatter:off");
        box.add();
        box.add("package %s;", genPackageName);
        box.add();

        Set<EClass> nonAbstractClasses = set();
        for (EClass cls: classes) {
            if (!cls.isAbstract()) {
                nonAbstractClasses.add(cls);
            }
        }

        Set<EClassifier> featureClassifiers = set();
        boolean useList = false;
        for (EClass cls: classes) {
            if (cls.isAbstract()) {
                continue;
            }
            for (EStructuralFeature feat: cls.getEAllStructuralFeatures()) {
                featureClassifiers.add(feat.getEType());
                if (feat.isMany()) {
                    useList = true;
                }
            }
        }

        Set<String> importsSet = set();
        for (EClass cls: nonAbstractClasses) {
            importsSet.add(getJavaTypeName(cls));
        }
        for (EClassifier cls: featureClassifiers) {
            importsSet.add(getJavaTypeName(cls));
        }
        if (useList) {
            importsSet.add("java.util.List");
        }
        for (EFactory fact: factories) {
            String imp = getJavaTypeName(fact);
            importsSet.add(imp);
        }

        List<String> imports = set2list(importsSet);
        for (String imp: JavaCodeUtils.formatImports(imports, genPackageName)) {
            box.add(imp);
        }
        box.add();

        box.add("/**");
        box.add(" * Helper class with static constructor methods for the \"%s\" language.", pkg.getName());
        box.add(" */");
        box.add("public class %s {", genClassName);

        box.indent();
        box.add("/** Constructor for the {@link %s} class. */", genClassName);
        box.add("private %s() {", genClassName);
        box.indent();
        box.add("// Static class.");
        box.dedent();
        box.add("}");
        box.dedent();

        for (EClass cls: classes) {
            if (cls.isAbstract()) {
                continue;
            }
            box.add();
            genConstructorForClass1(cls, box);
            if (cls.getEAllStructuralFeatures().size() > 0) {
                // Only generate if we have structural features; otherwise, we
                // would get two constructors without arguments...
                box.add();
                genConstructorForClass2(cls, classes, box);
            }
        }
        box.add("}");
        return box;
    }

    /**
     * Generate parameter-less constructor code for an {@link EClass}.
     *
     * @param cls The {@link EClass} to generate the code for.
     * @param box The generated code (appended in-place).
     */
    private static void genConstructorForClass1(EClass cls, CodeBox box) {
        String clsName = cls.getName();
        String factName = cls.getEPackage().getEFactoryInstance().getClass().getSimpleName();
        Assert.check(factName.endsWith("Impl"));
        factName = Strings.slice(factName, 0, -4);
        box.indent();
        box.add("/**");
        box.add(" * Returns a new instance of the {@link %s} class. This constructs a new object, without setting any "
                + "of its features.", clsName);
        box.add(" *");
        box.add(" * @return A new instance of the {@link %s} class.", clsName);
        box.add(" */");
        box.add("public static %s new%s() {", clsName, clsName);

        box.indent();
        box.add("return %s.eINSTANCE.create%s();", factName, clsName);
        box.dedent();

        box.add("}");
        box.dedent();
    }

    /**
     * Generate constructor with parameters code for an {@link EClass}.
     *
     * @param cls The {@link EClass} to generate the code for.
     * @param classes All the classes in all the (sub-)packages that we are generating code for.
     * @param box The generated code (appended in-place).
     */
    private static void genConstructorForClass2(EClass cls, List<EClass> classes, CodeBox box) {
        List<EStructuralFeature> feats = getAllStructuralFeatures(cls);

        String clsName = cls.getName();
        String factName = cls.getEPackage().getEFactoryInstance().getClass().getSimpleName();
        Assert.check(factName.endsWith("Impl"));
        factName = Strings.slice(factName, 0, -4);

        box.indent();
        box.add("/**");
        box.add(" * Returns a new instance of the {@link %s} class.", clsName);
        box.add(" *");
        for (EStructuralFeature feat: feats) {
            if (feat.getLowerBound() == 0) {
                box.add(" * @param %s The \"%s\" of the new \"%s\". Multiplicity %s. May be {@code null} to skip "
                        + "setting the \"%s\", or to set it later.", JavaCodeUtils.makeJavaName(feat.getName()),
                        feat.getName(), clsName, getMultiplicityText(feat), feat.getName());
            } else {
                box.add(" * @param %s The \"%s\" of the new \"%s\". Multiplicity %s. May be {@code null} to set "
                        + "the \"%s\" later.", JavaCodeUtils.makeJavaName(feat.getName()), feat.getName(), clsName,
                        getMultiplicityText(feat), feat.getName());
            }
        }
        box.add(" * @return A new instance of the {@link %s} class.", clsName);
        box.add(" */");
        String line = fmt("public static %s new%s(", clsName, clsName);
        boolean firstArg = true;
        for (EStructuralFeature feat: feats) {
            if (!firstArg) {
                line += ", ";
            }
            line += fmt("%s %s", getStructuralFeatureTypeText(feat, classes),
                    JavaCodeUtils.makeJavaName(feat.getName()));
            firstArg = false;
        }
        box.add(line + ") {");

        box.indent();
        box.add("%s rslt_ = new%s();", clsName, clsName);
        for (EStructuralFeature feat: feats) {
            Assert.check(!feat.getName().startsWith("_"), "Structural features with names starting with an "
                    + "underscore character are not supported: " + feat.getName());
            Assert.check(!feat.getName().equals("rslt_"), "Structural features with name \"rslt_\" are not supported.");
            box.add("if (%s != null) {", JavaCodeUtils.makeJavaName(feat.getName()));
            box.indent();
            box.add("rslt_.%s(%s);", getSetterName(feat), JavaCodeUtils.makeJavaName(feat.getName()));
            box.dedent();
            box.add("}");
        }
        box.add("return rslt_;");
        box.dedent();

        box.add("}");
        box.dedent();
    }

    /**
     * Returns the multiplicity of a feature as "[lowerBound..upperBound]".
     *
     * @param feat The feature.
     * @return The multiplicity.
     */
    private static String getMultiplicityText(EStructuralFeature feat) {
        String upperBound = (feat.getUpperBound() == -1) ? "*" : String.valueOf(feat.getUpperBound());
        return fmt("[%d..%s]", feat.getLowerBound(), upperBound);
    }
}
